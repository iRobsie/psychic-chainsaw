<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Trippy Space Runner — V4 Edge Burst (updated)</title>
  <style>
    html,body{height:100%;margin:0;background:#000;overflow:hidden;font-family:Inter,system-ui,Arial}
    canvas{display:block;width:100vw;height:100vh}
    .ui-score{position:fixed;left:12px;top:12px;color:#fff;z-index:10;padding:8px;border-radius:8px;background:rgba(255,255,255,0.04);backdrop-filter: blur(6px);font-weight:700}
    .ui-tldr{position:fixed;right:12px;top:12px;color:#000;z-index:10;padding:8px;border-radius:8px;background:linear-gradient(180deg,#fff,#f2f2ff);font-weight:600;text-align:right}
    .ui-info{position:fixed;left:12px;top:56px;color:#fff;z-index:10;padding:6px;border-radius:6px;background:rgba(255,255,255,0.03);font-weight:700}
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div class="ui-score" id="score">Score: 0</div>
  <div class="ui-info" id="shapes">Shapes: orb/square/diamond/hex (bigger = more points)</div>
  <div class="ui-tldr" id="tldr">I dont know what I am doing<br>Please god save me<br>There is no end, there is no<br>      beginning.</div>

<script>
// Trippy Space Runner V4 — Edge Burst Update
// - Edge effects now alternate between two distinct bursts when player reaches the tunnel edge.
// - Crosshair glows faster and stronger when near the edge.
// - Cursor (crosshair) replaced with a continuous rainbow burst (animated rings + tiny particles).

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W = canvas.width = innerWidth; let H = canvas.height = innerHeight;
const CX = ()=>W/2, CY = ()=>H/2;

// Offscreen buffer safe init
let buf = document.createElement('canvas'); buf.width = Math.max(1,W); buf.height = Math.max(1,H); let bctx = buf.getContext('2d');
let tunnelRadius = Math.min(W,H)*0.48;
function resize(){ W = canvas.width = innerWidth; H = canvas.height = innerHeight; tunnelRadius = Math.min(W,H)*0.48; if(buf.width !== W || buf.height !== H){ buf.width = Math.max(1,W); buf.height = Math.max(1,H); bctx = buf.getContext('2d'); } }
window.addEventListener('resize', resize); resize();

// utils
function rand(a,b){return Math.random()*(b-a)+a}
function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
function hsvToRgb(h,s,v){ if(!isFinite(h)||isNaN(h)) h=0; if(!isFinite(s)||isNaN(s)) s=0; if(!isFinite(v)||isNaN(v)) v=0; h=((h%1)+1)%1; s=clamp(s,0,1); v=clamp(v,0,1); const i=Math.floor(h*6); const f=h*6-i; const p=v*(1-s); const q=v*(1-f*s); const t=v*(1-(1-f)*s); let r=0,g=0,b=0; switch(i%6){case 0:r=v;g=t;b=p;break;case 1:r=q;g=v;b=p;break;case 2:r=p;g=v;b=t;break;case 3:r=p;g=q;b=v;break;case 4:r=t;g=p;b=v;break;case 5:r=v;g=p;b=q;break;} r=Math.round(clamp(r,0,1)*255); g=Math.round(clamp(g,0,1)*255); b=Math.round(clamp(b,0,1)*255); if(!isFinite(r)||!isFinite(g)||!isFinite(b)) return {r:255,g:255,b:255}; return {r,g,b}; }

// progression parameters
let baseSpeed = 6.0; const SPEED_PER_PASS = 0.8; const TIME_ACCEL = 0.005; const MAX_SPEED = 38.0; const MAX_OBJECTS = 28;

// game state
let time = 0; let score = 0; let speedMultiplier = 1; const player = {x:0,y:0,vx:0,vy:0}; let target={x:0,y:0}; let pointer={down:false,lastX:0,lastY:0}; let passes = 0;

// edge detection state
let prevNearEdge = false; let edgeEffectToggle = 0; let isNearEdge = false;

// world objects
const stars=[]; const objects=[]; const particles=[];
for(let i=0;i<160;i++) stars.push({x:rand(-W,W), y:rand(-H,H), z:rand(80,3200), size:rand(0.2,2.4), hue:Math.random(), sat:rand(0.6,0.95), val:rand(0.6,0.95), wob:rand(0.05,0.8), prev:null});
for(let i=1;i<=6;i++) spawnObject(i*560 + rand(-80,80));

function spawnObject(z){ if(objects.length >= MAX_OBJECTS) return; const size = rand(60,220); const types = ['ring','orb','square','diamond','hex']; const type = types[Math.floor(rand(0,types.length))]; objects.push({ x:rand(-W*0.35,W*0.35), y:rand(-H*0.28,H*0.28), z:z, size:size, thickness:rand(6,20), hue:Math.random(), type:type, rot:rand(0,Math.PI*2), passed:false }); }

// input
canvas.addEventListener('pointerdown', e=>{ pointer.down=true; pointer.lastX=e.clientX; pointer.lastY=e.clientY; });
window.addEventListener('pointermove', e=>{ if(pointer.down){ const dx=e.clientX-pointer.lastX; const dy=e.clientY-pointer.lastY; target.x += dx * 0.85; target.y += dy * 0.85; target.x = clamp(target.x,-W*0.65,W*0.65); target.y = clamp(target.y,-H*0.55,H*0.55); pointer.lastX=e.clientX; pointer.lastY=e.clientY; } });
window.addEventListener('pointerup', ()=>{ pointer.down=false; });
canvas.addEventListener('click', ()=>{ target.x=0; target.y=0; });
const keys={}; window.addEventListener('keydown', e=>{ keys[e.key]=true; if(e.key===' '){ speedMultiplier = 3.0; } }); window.addEventListener('keyup', e=>{ keys[e.key]=false; if(e.key===' '){ speedMultiplier = 1; } });

// scoring & effects
const SHAPE_SCORE_BASE = { ring:70, orb:50, square:90, diamond:120, hex:110 };
const SHAPE_MULT = { ring:1.0, orb:0.9, square:1.2, diamond:1.6, hex:1.45 };

function spawnParticle(x,y,vx,vy,life,size,color,type){ particles.push({x,y,vx,vy,life,age:0,size,color,type}); }
function spawnEffects(sx,sy,baseHue,scaleBonus=1){ for(let i=0;i<10;i++){ const ang=Math.random()*Math.PI*2; const sp=rand(1.4,6.8)*scaleBonus; const col=hsvToRgb(((baseHue+Math.random()*0.2-0.1)+1)%1,0.98,0.98); spawnParticle(sx + rand(-10,10), sy + rand(-10,10), Math.cos(ang)*sp, Math.sin(ang)*sp, rand(0.5,1.4), rand(0.8,2.2), `rgb(${col.r},${col.g},${col.b})`, 'spark'); } particles.push({type:'shock', obj:{x:sx,y:sy,r:6,maxR:rand(80,220)*scaleBonus,a:1.0,hue:baseHue}}); }

// NEW: two distinct edge bursts
function spawnEdgeSparkBurst(cx,cy){ // fast colorful sparks
  for(let i=0;i<22;i++){ const ang=Math.random()*Math.PI*2; const sp=rand(2,14); const col=hsvToRgb(Math.random(),0.95,1); spawnParticle(cx + rand(-6,6), cy + rand(-6,6), Math.cos(ang)*sp, Math.sin(ang)*sp, rand(0.6,1.6), rand(0.8,2.6), `rgb(${col.r},${col.g},${col.b})`, 'spark'); }
}
function spawnEdgeFireBurst(cx,cy){ // fewer, larger fireworks
  for(let i=0;i<12;i++){ const ang=(i/12)*Math.PI*2 + rand(-0.2,0.2); const sp=rand(3.5,18); const col=hsvToRgb(((time*0.08 + i*0.02)%1+1)%1,0.98,0.98); spawnParticle(cx,cy,Math.cos(ang)*sp,Math.sin(ang)*sp - rand(0,4), rand(0.9,2.6), rand(2.2,4.8), `rgb(${col.r},${col.g},${col.b})`, 'fire'); } particles.push({type:'shock', obj:{x:cx,y:cy,r:8,maxR:rand(90,260),a:1.0,hue:Math.random()}}); }

function triggerEdgeEffect(cx,cy){ // alternate between spark and fire bursts
  if(edgeEffectToggle % 2 === 0) spawnEdgeSparkBurst(cx,cy); else spawnEdgeFireBurst(cx,cy); edgeEffectToggle++; }

function scoreAndPass(obj,rx,ry){ const base = SHAPE_SCORE_BASE[obj.type] || 60; const mult = SHAPE_MULT[obj.type] || 1; const dist = Math.hypot(rx-CX(), ry-CY()); const inner = (obj.size * (900/(obj.z+900))) * 0.35; const precision = dist < inner ? 1.25 : 1.0; const gained = Math.floor(base * mult * precision); score += gained; passes++; spawnEffects(rx,ry,obj.hue, precision>1?1.4:1.0); }

// tunnel collision
function checkTunnelCollision(){ const dist = Math.hypot(player.x, player.y); const limit = tunnelRadius*0.99; if(dist > limit){ const nx = player.x/dist, ny = player.y/dist; player.x = nx*limit; player.y = ny*limit; const vDot = player.vx*nx + player.vy*ny; player.vx -= (1.2 * vDot) * nx; player.vy -= (1.2 * vDot) * ny; for(let i=0;i<6;i++){ const ang=Math.random()*Math.PI*2; const sp=rand(1.6,5.2); const col=hsvToRgb(Math.random(),0.9,0.95); spawnParticle(CX() + nx*limit*0.98 + rand(-6,6), CY() + ny*limit*0.98 + rand(-6,6), Math.cos(ang)*sp, Math.sin(ang)*sp, 0.45, rand(0.6,1.6), `rgb(${col.r},${col.g},${col.b})`, 'spark'); } // always trigger an edge effect on collision
    triggerEdgeEffect(CX(), CY()); } }

function update(dt){ time += dt; // compute current speed
  const rawSpeed = baseSpeed + passes * SPEED_PER_PASS + (time * TIME_ACCEL);
  const currentSpeed = Math.min(MAX_SPEED, rawSpeed);
  const taperThreshold = MAX_SPEED * 0.66; let speedFactor = 1;
  if(currentSpeed > taperThreshold){ const over = (currentSpeed - taperThreshold) / (MAX_SPEED - taperThreshold + 1e-6); speedFactor = 1 - Math.pow(over,1.2)*0.6; }
  const forward = currentSpeed * speedMultiplier * speedFactor * (dt*60);

  // input
  let kx=0,ky=0; if(keys['ArrowLeft']||keys['a']) kx -=1; if(keys['ArrowRight']||keys['d']) kx +=1; if(keys['ArrowUp']||keys['w']) ky -=1; if(keys['ArrowDown']||keys['s']) ky +=1; target.x += kx * 9 * Math.max(1,Math.min(W/900,2)); target.y += ky * 8 * Math.max(1,Math.min(H/700,2));
  const stiffness = 0.09; const drag = 0.82; const dx = (target.x - player.x); const dy = (target.y - player.y); player.vx += dx*stiffness; player.vy += dy*stiffness; player.vx *= drag; player.vy *= drag; player.x += player.vx*(dt*60); player.y += player.vy*(dt*60);
  if(!pointer.down && !keys['ArrowLeft'] && !keys['ArrowRight'] && !keys['a'] && !keys['d']){ target.x *= 0.995; target.y *= 0.995; }

  // edge proximity detection (player world position)
  const distToCenter = Math.hypot(player.x, player.y);
  isNearEdge = distToCenter > tunnelRadius * 0.82;
  if(isNearEdge && !prevNearEdge){ // just entered near-edge region -> trigger alternating effect
    triggerEdgeEffect(CX(), CY()); }
  prevNearEdge = isNearEdge;

  // stars
  for(let s of stars){ s.z -= forward * (0.5 + s.size*0.6); if(s.z < 12){ s.z += rand(1600,3000); s.x = rand(-W,W); s.y = rand(-H,H); s.hue=Math.random(); s.prev=null; } }

  // objects
  for(let obj of objects){ obj.z -= forward * (0.92 + obj.size/2000); obj.rot += (forward*0.0016) * (obj.size/160); if(obj.z < -300){ obj.z += rand(3800,8200); obj.x = rand(-W*0.35,W*0.35); obj.y = rand(-H*0.28,H*0.28); obj.passed=false; obj.hue=Math.random(); } if(!obj.passed && obj.z < 140 && obj.z > -120){ const scale = 900/(obj.z+900); const rx = (obj.x - player.x)*scale + CX(); const ry = (obj.y - player.y)*scale + CY(); const screenRadius = obj.size * scale; const dist = Math.hypot(rx-CX(), ry-CY()); if(dist < screenRadius * 0.55){ obj.passed = true; scoreAndPass(obj, rx, ry); } } }

  const spawnChance = clamp(0.012 + passes*0.0014, 0.012, 0.06);
  if(objects.length < MAX_OBJECTS && Math.random() < spawnChance) spawnObject(1200 + rand(0,2400));

  // particles update
  for(let i=particles.length-1;i>=0;i--){ const p=particles[i]; if(p.type==='shock'){ p.obj.r += (90 + Math.random()*120)*dt; p.obj.a -= 1.2*dt; if(p.obj.a <= 0) particles.splice(i,1); continue; } p.age += dt; if(p.age >= p.life){ particles.splice(i,1); continue; } p.vy += 9.8*0.18*dt; p.vx *= 0.995; p.vy *= 0.995; p.x += p.vx*60*dt; p.y += p.vy*60*dt; }

  // collision
  checkTunnelCollision(); }

// Render: rainbow cursor burst + faster glow when near edge
function renderToBuffer(bctx){ if(!buf || buf.width<=0||buf.height<=0){ buf.width = Math.max(1,W); buf.height = Math.max(1,H); bctx = buf.getContext('2d'); }
  bctx.clearRect(0,0,W,H); bctx.fillStyle='#000'; bctx.fillRect(0,0,W,H);
  // tunnel faint lines
  bctx.save(); bctx.translate(CX(),CY()); const rim = tunnelRadius; for(let i=0;i<360;i+=8){ const ang=(i/180)*Math.PI + time*0.015; const r0=rim*0.86 + Math.sin(i*0.02 + time*0.03)*8; const r1=rim*1.02 + Math.cos(i*0.01 + time*0.02)*6; const h=((i/360)+time*0.02)%1; const c=hsvToRgb(h,0.95,0.85); bctx.strokeStyle = `rgba(${c.r},${c.g},${c.b},${0.03 + Math.abs(Math.cos(time*0.015+i))*0.03})`; bctx.lineWidth=1; bctx.beginPath(); bctx.moveTo(Math.cos(ang)*r0,Math.sin(ang)*r0); bctx.lineTo(Math.cos(ang)*r1,Math.sin(ang)*r1); bctx.stroke(); } bctx.restore();

  // draw objects
  for(let obj of objects){ const scale = 900/(obj.z + 900); if(scale<=0) continue; const rx = (obj.x - player.x)*scale + CX(); const ry = (obj.y - player.y)*scale + CY(); const sr = obj.size * scale; const thickness = Math.max(2, obj.thickness*scale*0.7); if(obj.z < -260) continue; const baseHue = ((obj.hue + (obj.rot%(Math.PI*2))/(Math.PI*2)*0.15)%1 + 1)%1; bctx.save(); bctx.translate(rx,ry); bctx.rotate(obj.rot + Math.sin(time*0.04)*(0.06 + obj.size/900));
    if(obj.type === 'ring'){ for(let i=0;i<2;i++){ const rr = sr*(1 - i*0.18); bctx.beginPath(); bctx.lineWidth = thickness*(1 - i*0.18); const h = ((baseHue + i*0.04 + time*0.02)%1+1)%1; const c = hsvToRgb(h,0.96,0.95); bctx.strokeStyle = `rgba(${c.r},${c.g},${c.b},${0.84 - i*0.22})`; bctx.arc(0,0,rr,0,Math.PI*2); bctx.stroke(); } }
    else if(obj.type === 'orb'){ const c = hsvToRgb(baseHue,0.96,0.98); const g = bctx.createRadialGradient(0,0,sr*0.05,0,0,sr*1.4); g.addColorStop(0,`rgba(${c.r},${c.g},${c.b},0.98)`); g.addColorStop(1,'rgba(0,0,0,0)'); bctx.fillStyle = g; bctx.beginPath(); bctx.arc(0,0,sr*0.6,0,Math.PI*2); bctx.fill(); bctx.lineWidth = Math.max(1, thickness*0.6); bctx.strokeStyle = `rgba(${c.r},${c.g},${c.b},0.88)`; bctx.beginPath(); bctx.arc(0,0,sr*0.82,0,Math.PI*2); bctx.stroke(); }
    else { const pts=[]; if(obj.type==='square'||obj.type==='diamond'){ const r = sr*0.8; const angleOffset = obj.type==='diamond'?Math.PI/4:0; const steps=4; for(let i=0;i<steps;i++){ const a=angleOffset + (i/steps)*Math.PI*2; pts.push([Math.cos(a)*r,Math.sin(a)*r]); } } else { const r = sr*0.78; const steps=6; for(let i=0;i<steps;i++){ const a=(i/steps)*Math.PI*2; pts.push([Math.cos(a)*r,Math.sin(a)*r]); } } const h = (baseHue + time*0.03) % 1; const col = hsvToRgb(h,0.98,0.96); bctx.beginPath(); bctx.moveTo(pts[0][0],pts[0][1]); for(let i=1;i<pts.length;i++) bctx.lineTo(pts[i][0],pts[i][1]); bctx.closePath(); bctx.fillStyle = `rgba(${col.r},${col.g},${col.b},0.92)`; bctx.fill(); bctx.lineWidth = Math.max(1, thickness*0.7); bctx.strokeStyle = `rgba(${col.r},${col.g},${col.b},0.96)`; bctx.stroke(); }
    bctx.restore(); }

  // stars
  for(let s of stars){ const scale = 900/(s.z+900); const x=(s.x-player.x)*scale + CX(); const y=(s.y-player.y)*scale + CY(); const sz=Math.max(0.4, s.size*scale*0.8); if(x < -200 || x > W+200 || y < -200 || y > H+200){ s.prev=null; continue; } const hueVal = ((s.hue + Math.sin(time*s.wob)*0.02)%1+1)%1; const rgb = hsvToRgb(hueVal, s.sat||0.9, s.val||0.9); bctx.fillStyle = `rgba(${rgb.r},${rgb.g},${rgb.b},0.6)`; bctx.beginPath(); bctx.arc(x,y, Math.max(0.5,sz*0.5),0,Math.PI*2); bctx.fill(); s.prev={x,y}; }

  // particles
  for(let p of particles){ if(p.type==='shock') continue; const alpha=Math.max(0,1 - (p.age/p.life)); bctx.fillStyle = p.color.replace(')', `,${alpha})`).replace('rgb','rgba'); bctx.beginPath(); bctx.arc(p.x,p.y,p.size,0,Math.PI*2); bctx.fill(); }
}

function drawMain(){ ctx.clearRect(0,0,W,H); ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H);
  // ambient subtle RGB
  ctx.save(); ctx.globalCompositeOperation='lighter'; for(let i=0;i<3;i++){ const hue=((time*6 + i*80)%360)/360; const c=hsvToRgb(hue,0.95,0.9); const rg = ctx.createRadialGradient(CX() + Math.sin(time*0.08 + i)*W*0.12, CY() + Math.cos(time*0.06 + i)*H*0.08, 0, CX(), CY(), Math.max(W,H)*0.9); rg.addColorStop(0, `rgba(${c.r},${c.g},${c.b},${0.03 + 0.02*Math.abs(Math.sin(time*0.9 + i))})`); rg.addColorStop(1, 'rgba(0,0,0,0)'); ctx.fillStyle=rg; ctx.fillRect(0,0,W,H); } ctx.restore();

  // subtle lightning
  if(Math.random() < 0.02 && Math.abs(Math.sin(time*0.5))>0.6){ drawFractalLightning(ctx, CX() + (Math.sin(time*0.9)*W*0.04), CY() + (Math.cos(time*0.6)*H*0.03), Math.min(W,H)*0.5, 2, (time*0.02)%1); }

  renderToBuffer(bctx);
  if(!buf || buf.width<=0 || buf.height<=0){ buf.width=Math.max(1,W); buf.height=Math.max(1,H); bctx=buf.getContext('2d'); }
  try{ ctx.save(); ctx.globalCompositeOperation='source-over'; ctx.drawImage(buf,0,0); ctx.globalCompositeOperation='lighter'; const layers=3; for(let i=1;i<=layers;i++){ const k = 1 + (i*0.006) + (Math.sin(time*0.6 + i)*0.003); const sx = - (W*(k-1))/2; const sy = - (H*(k-1))/2; ctx.globalAlpha = 0.10 * (1 - i/(layers+1)); ctx.drawImage(buf, sx, sy, W*k, H*k); } ctx.globalAlpha=1; ctx.globalCompositeOperation='source-over'; ctx.restore(); }catch(e){}

  // overlay particles
  ctx.save(); ctx.globalCompositeOperation='lighter'; for(let p of particles){ if(p.type==='shock'){ const o=p.obj; const c=hsvToRgb(o.hue,0.95,0.92); ctx.beginPath(); ctx.lineWidth = 4 + Math.sin(time*6)*1.2; ctx.strokeStyle = `rgba(${c.r},${c.g},${c.b},${Math.max(0,o.a)})`; ctx.arc(o.x,o.y,o.r,0,Math.PI*2); ctx.stroke(); continue; } const alpha=Math.max(0,1 - (p.age/p.life)); ctx.fillStyle = p.color.replace(')', `,${alpha})`).replace('rgb','rgba'); ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,Math.PI*2); ctx.fill(); } ctx.restore();

  // CURSOR / CROSSHAIR - replaced with rainbowy constant burst
  const cx = CX(), cy = CY(); // compute glow boost when near edge
  const glowBoost = isNearEdge ? 1.8 : 1.0; const glowSpeed = isNearEdge ? 2.6 : 1.0; // faster animation near edge

  // animated rainbow rings
  ctx.save(); ctx.translate(cx,cy); ctx.globalCompositeOperation='lighter';
  const ringCount = 5; for(let r=0;r<ringCount;r++){
    const radius = 12 + r*10 + Math.sin(time*2.0*glowSpeed + r*0.6)*4*glowBoost;
    const hue = ((time*0.26 + r*0.08) % 1 + 1) % 1;
    const col = hsvToRgb(hue, 0.98, 0.95);
    ctx.beginPath(); ctx.lineWidth = 2.2 * (1 + r*0.12) * glowBoost; ctx.strokeStyle = `rgba(${col.r},${col.g},${col.b},${0.18 + 0.12*(ringCount - r)})`; ctx.arc(0,0,radius,0,Math.PI*2); ctx.stroke();
  }
  // tiny rotating rainbow points
  for(let i=0;i<10;i++){ const ang = time*4.0*glowSpeed + i*(Math.PI*2/10); const rr = 36 + Math.sin(time*3.2 + i)*6; const hue = ((time*0.4 + i*0.09) % 1 + 1) % 1; const col=hsvToRgb(hue,0.98,0.98); ctx.beginPath(); ctx.fillStyle = `rgba(${col.r},${col.g},${col.b},0.95)`; ctx.arc(Math.cos(ang)*rr, Math.sin(ang)*rr, 3.2 * glowBoost, 0, Math.PI*2); ctx.fill(); }
  ctx.restore();

  // crisp crosshair center (still present but smaller) with stronger glow when near edge
  ctx.save(); ctx.translate(cx,cy); ctx.globalCompositeOperation='lighter'; const hue=(time*0.12)%1; const hc=hsvToRgb(hue,0.98,0.98); const haloRadius = 18 * glowBoost; const halo = ctx.createRadialGradient(0,0,0,0,0,haloRadius*3); halo.addColorStop(0, `rgba(${hc.r},${hc.g},${hc.b},${0.42 * glowBoost})`); halo.addColorStop(1, 'rgba(0,0,0,0)'); ctx.fillStyle=halo; ctx.beginPath(); ctx.arc(0,0,haloRadius*1.8,0,Math.PI*2); ctx.fill(); ctx.lineWidth=2; ctx.strokeStyle = `rgba(${hc.r},${hc.g},${hc.b},${0.98})`; ctx.beginPath(); ctx.moveTo(-10,0); ctx.lineTo(10,0); ctx.moveTo(0,-10); ctx.lineTo(0,10); ctx.stroke(); ctx.beginPath(); ctx.arc(0,0,5 * glowBoost,0,Math.PI*2); ctx.fillStyle = `rgba(${hc.r},${hc.g},${hc.b},0.98)`; ctx.fill(); ctx.restore();

  // HUD
  document.getElementById('score').textContent = 'Score: ' + score;
}

// fractal lightning (kept subtle)
function drawFractalLightning(ctx,cx,cy,spread,depth,hueShift){ ctx.save(); ctx.globalCompositeOperation='lighter'; function branch(x,y,angle,len,th,level){ if(level>depth||len<8) return; const seg=Math.max(2,Math.floor(len/10)); let px=x,py=y; for(let i=0;i<seg;i++){ const nx=px+Math.cos(angle+(Math.random()-0.5)*0.4)*(len/seg); const ny=py+Math.sin(angle+(Math.random()-0.5)*0.4)*(len/seg); const hue=((time*0.02 + hueShift + level*0.02 + i/seg*0.06)%1+1)%1; const col=hsvToRgb(hue,0.95,0.9); ctx.strokeStyle=`rgba(${col.r},${col.g},${col.b},${0.12 + 0.18*(1-level/depth)})`; ctx.lineWidth=Math.max(0.8, th*(1 - i/seg*0.6)); ctx.beginPath(); ctx.moveTo(px,py); ctx.lineTo(nx,ny); ctx.stroke(); px=nx; py=ny; if(Math.random()<0.12&&level<depth) branch(px,py,angle+(Math.random()-0.5)*0.9,len*0.6,th*0.72,level+1); } } for(let b=0;b<2;b++){ branch(cx,cy,Math.random()*Math.PI*2, spread*(0.6+Math.random()*0.4), 5*(1+Math.random()*0.6),0); } ctx.restore(); }

let last = performance.now(); function loop(now){ const dt = Math.min(0.05,(now-last)/1000); update(dt); drawMain(); last = now; requestAnimationFrame(loop); } requestAnimationFrame(loop);

// expose debug
window.__game_v4_edge = { stars, objects, particles, player };
</script>
</body>
</html>
